class BRISK : public Feature2D
Класс для реализации BRISK обнаружения ключевых точек.


BRISK конструктор
C++: BRISK::BRISK(
int thresh=30,  //порог обнаружения FAST/AGAST
int octaves=3,   // октавы обнаружения. Используйте 0, чтобы сделать единую шкалу
float patternScale=1.0f  // применить эту шкалу с моделью, используемой для выборки окрестности характерной точки
)

BRISK конструктор для пользовательской модели
C++: BRISK::BRISK(
std::vector<float>& radiusList, // определяет радиусы (в пикселях),вокруг точки для взятия образцов
std::vector<int>& numberList,   // определяет число точек отбора проб на окружности выборки. Должно быть того же размера что и radiusList
float dMax=5.85f,  // Порог для коротких пар, используемых для формирования дескрипторов
float dMin=8.2f,  // Порог для длинных пар, используемых для формирования дескрипторов
std::vector<int> indexChange=std::vector<int>()  //  индекс переназначения бит
)


BRISK::operator()
Находит ключевые точки на изображении и вычисляет их дескриптор
C++: void BRISK::operator()(
	InputArray image,  // входное изображениие 8 бит оттенков серого
	InputArray mask,    // Маска операции
	vector<KeyPoint>& keypoints,   // выходной вектор ключевых точек
	OutputArray descriptors,    // Выходные дескрипторы. cv::noArray() в случае, если в них нету необходимости.
	bool useProvidedKeypoints=false   // true - использование предоставленного вектора ключевых точек. False - обнаружение точек.
	) 

	
С++ пример.
	
#include <iostream>
#include <stdlib.h>

#include <opencv2/features2d/features2d.hpp>  // библиотека для  cv::BRISK
#include <opencv2/highgui/highgui.hpp>        // библиотека для cv::imread



int main(int argc, char **argv) {

//Получаем изображение
std::string in_filename = argv[1]; 

//порог обнаружения FAST/AGAST
int thresh = argc>3 ? atoi(argv[3]) : 30;

// октавы обнаружения. Используйте 0, чтобы сделать единую шкалу
int octaves = argc>4 ? atoi(argv[4]) : 3;

// применить эту шкалу с моделью, используемой для выборки окрестности характерной точки
float pattern_scale = 1;

cv::Mat in_pic = cv::imread(in_filename);


  // Инициализация BRISK

cv::BRISK brisk(thresh, octaves, pattern_scale);
brisk.create("Feature2D.BRISK");

// вычисление ключевых точек, используя BRISK

  std::vector<cv::KeyPoint> keypoints;
  brisk.detect(in_pic, keypoints);
  std::cout << "detected " << keypoints.size() << " keypoints" << std::endl;

}

--------------------------

Сравнение BRISK и ORB

// BRISK параметры
int Threshl=30;
int Octaves=4;
float PatternScales=1.0f;

// ORB pпараметры
int nFeatures=2000;
float scaleFactor=1.2f;
int nLevels=8;

// Инициализация BRISK
BRISK  BRISKD(Threshl, Octaves, PatternScales);

// Инициализация ORB
ORB ORBD(nFeatures, scaleFactor, nLevels);

vector<KeyPoint> kpts;
Mat descriptors;

Mat img = cv::imread("Path to the bolt image", IMREAD_GRAYSCALE );

// вычисление ключевых точек, используя ORB
ORBD.detect(img,kpts); 

// вычисление ключевых точек, используя BRISK
BRISKD.compute(img, kpts, descriptors); 	